function TorsionField3(E1)
//We Pick and Elliptic Curve and a WeierstrassModel y^2=f(x)
    K:=BaseRing(E1);
    P<x>:=PolynomialRing(K);
    E:=WeierstrassModel(E1);
    v2:=aInvariants(E);
// Then we adjoint the roots of f(x) to Q9 to obtain a field L;
    f:=x^3+v2[2]*x^2+v2[4]*x+v2[5]*1;
    g:=DivisionPolynomial(E,3);
    L:=SplittingField(g);
    R<x>:=PolynomialRing(L);
    Rot:=Roots(R!g);
    z1:=Evaluate(R!f,Rot[1][1]);
    L:=SplittingField(x^2-z1);
return DefiningPolynomial(L,K),L,K,aInvariants(E1),E1;
end function;



//This function checks Corollary 4.2 and checks that the curves given at the end of Section 4 do realize the types in corollary 4.2 
function Check(K)
assert Prime(K) gt 3;
pi:=UniformizingElement(K);
E:=[];
E[1]:=EllipticCurve([0,0,0,pi^2,0]);
E[2]:=EllipticCurve([0,0,0,0,pi^2]);
E[3]:=EllipticCurve([0,0,0,pi,0]);
E[4]:=EllipticCurve([0,0,0,0,pi]);

for Curve in E do
f,L,K:=TorsionField3(Curve);
Curve;
print("Has image of inertia cyclic of order");RamificationDegree(L,K); //The ramification degree of the 3-TorsionField is the size of inertia
print("And its type is");
if IsAbelian(L,K) then print("Principal Series"); else print("Supercuspidal Unramified"); end if; // We can decide between Principal Series or SuperCuspidal by cheking is the 3-torsion is abelian or not.
print("--------------------------------------------");
end for;
return 0;
end function;





