
Z:=Integers();
Q2:=pAdicField(2,150);
R<x>:=PolynomialRing(Q2);
Q4<a>:=ext<Q2|x^2-x-1>;
RR<t>:=PolynomialRing(Q4);
b:=Roots(t^2-5)[1][1];
c:=1+2*b;
Twists:=[-c*b,b,-1,c,c*b,-b,-2,2*c,2*c*b,-2*b,2,-2*c,2*b,-2*c*b,-c];



//Conductor 3
E31:=EllipticCurve([0,1,0,2,Q4.1^2]);
E32:=EllipticCurve([0,Q4!1,0,1,2]);
E33:=EllipticCurve([0,4,0,4,4*Q4.1^2]);

//Conductor 5
E51:=EllipticCurve([0,1,0,2*Q4.1,4*Q4.1^2]);
E52:=EllipticCurve([0,1,0,4,4*Q4.1]);

//Conductor 6
E61:=EllipticCurve([0,1,0,2,2*Q4.1]);

//Condcutor 7
E71:=EllipticCurve([0,4*Q4.1^2,0,2*Q4.1,4]);
E72:=EllipticCurve([0,0,0,(-120*a+375)*4,(610*a-1455)*16]);
E74:=EllipticCurve([0,2*(a+1),0,a,4*(a+1)]);
E76:=EllipticCurve([0,4*a,0,4*a,16*a]);
E714:=EllipticCurve([0,2*a,0,2*a,8*a]);
E715:=EllipticCurve([0,-4,0,8,-32*a]);

//This function computes the field of 3 torsion of the elliptic curve
function TorsionField3(E1)
//We Pick and Elliptic Curve and a WeierstrassModel y^2=f(x)
    K:=BaseRing(E1);
    P<x>:=PolynomialRing(K);
    E:=WeierstrassModel(E1);
    E:=E1;
    v2:=aInvariants(E);
// Then we adjoint the roots of f(x) to Q9 to obtain a field L;
    f:=x^3+v2[2]*x^2+v2[4]*x+v2[5]*1;
    g:=DivisionPolynomial(E,3);
    L:=SplittingField(g);
    R<x>:=PolynomialRing(L);
    Rot:=Roots(R!g);
    z1:=Evaluate(R!f,Rot[1][1]);
    L:=SplittingField(x^2-z1);
return <DefiningPolynomial(L,K),L,K,aInvariants(E1),E1>;
end function;



//This function computes the value of the character describing the inertial type of the curve E, i is the number of the cubic extension over which the type of E
//becomes triple imprimitive and j is the quadratic extension from which the base change of the type is induced by a character both of them label as in the tables
//in the paper. 
//It outputs 4 objects, first the field K (cubic over Q4) over which the type of E becomes triple imprimitive, second the field M (quadratic over K) from which the type is induced, third a list with the 
//generators of the group as elements of K and the exponent of the group through wich the character factors. With these output one can ask magma for polynomials defining the fields F,K and for the expression of the generators of the group.
//To obtain generators with shorter expressions one can take the generators output by the function and trucate them modulo \p^f.

function character(E,i,j)
F<vf>:=FieldOfFractions(AllExtensions(Q4,3)[i]);
K<vk>:=FieldOfFractions(AllExtensions(F,2)[j]);
f:=Z!(Valuation(Conductor(BaseChange(E,F)))-Valuation(Discriminant(K,F)));
KLow:=ChangePrecision(K,50);
OK:=Integers(KLow);
UnitK,m:=UnitGroup(OK);
KxL:=PolynomialRing(KLow);
Kx:=PolynomialRing(K);
E:=BaseChange(E,K);
OL:=Integers(TorsionField3(E)[2]);
PolyK:=DefiningPolynomial(KLow,Q2);
Qx:=PolynomialRing(Rationals());
PolK:=Qx!PolyK;
KGlob:=NumberField(PolK);
KGlob:=OptimisedRepresentation(KGlob);
OKG:=Integers(KGlob);
P:=Factorisation(2*OKG)[1,1];
QK:=quo<OKG|P^f>;
print("The group OM/q^f has structure:");
UK,toQK:=UnitGroup(QK);
UK;
LocGen:=[];
GlobGen:=[];
Gen:=[];
for i in [1..#Generators(UK)] do
UK.i;
Gen:=Append(Gen,UK.i);
GlobGen:=Append(GlobGen,OKG!toQK(UK.i));
qx:=MinimalPolynomial(OKG!toQK(UK.i));
z:=Roots(Kx!qx)[1,1];
LocGen:=Append(LocGen,z);
//NormEquation(OL,m,z)[1];
end for;

Trivial:=[];
Quadra:=[];
Cuart:=[];
Cuarti:=[];
CuartNot:=[];
TrivialG:=[];
QuadraG:=[];
CuartG:=[];
CuartiG:=[];
CuartNotG:=[];
for i in [1..#LocGen] do
if NormEquation(OL,m,LocGen[i]) then
Trivial:=Append(Trivial,i);
TrivialG:=Append(TrivialG,Gen[i]);
else if NormEquation(OL,m,LocGen[i]^2) then
Quadra:=Append(Quadra,i);
QuadraG:=Append(QuadraG,Gen[i]);
else Cuart:=Append(Cuart,i);
end if;
end if;
end for;

for i in [1..#Cuart] do
if NormEquation(OL,m,(LocGen[Cuart[1]]*LocGen[Cuart[i]])) then
CuartNot:=Append(CuartNot,Cuart[i]);
CuartNotG:=Append(CuartNotG,Gen[Cuart[i]]);
else
Cuarti:=Append(Cuarti,Cuart[i]);
CuartiG:=Append(CuartiG,Gen[Cuart[i]]);
end if;
end for;

print("The character is trivial on the generators");
TrivialG;
print("The character has value -1 on the genertors");
QuadraG;
print("The character has value i on the genertors");
CuartiG;
print("The character has value -i on the genertors");
CuartNotG;
print("------------------------------");

return <F,K,LocGen,f>;
end function;




// The next comment provides an example of how to proceed to compute explicitely the character of the extension M_39 defining the type of the curve E74. 
/* 
T:=character(E71,2,39);

DefiningPolynomial(T[1]);
DefiningPolynomial(T[2]);

for i in [1..#T[3]] do
print("Generator"),i;
ChangePrecision(T[3,i],T[4]);
end for;
*/




// All the exceptional types are the type of one of the curves above or the type of a quadratic twist of the curves above.
// to compute the quadratic twist by the charcter epsilon j as define in the paper we use the generators in the list Twists.
// the following comment is an example of the computation of the type of E714 twist by epsilon_3.

/*
E:=QuadraticTwist(E714,Twists[3]);
T:=character(E,3,48);
DefiningPolynomial(T[1].1,Q4);
DefiningPolynomial(T[2],T[1]);

for i in [1..#T[3]] do
print("Generator"),i;
ChangePrecision(T[3,i],T[4]);
end for;
*/
