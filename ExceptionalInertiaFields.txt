
Q2:=pAdicField(2,16);
Q4:=UnramifiedExtension(Q2,2);

// This function computes all the field extension that can be produced by an exceptional inertial type that becomes triple imprimitive over the cubic extension K_i/Q4, with 0<i<5
// The output consist of 2 object, first a list with a generator for each the three quadratic extensions of M_ij that form a Galois orbit that is a subgroup of order 4, Second a 
// list where the i-th element is a list containing for each triple M_ij all the fields L that are, quadratic over the compositum of the M_ij  
// and such that L/Q4 has Galois group SL_2(F3).
// See the example at the end for a more concrete explanation.


function Exceptionals(i)
Ext:=AllExtensions(Q4,3);
K<vk>:=FieldOfFractions(Ext[i]);
Gal:=Automorphisms(K,Q4);
SelGr,fs:=pSelmerGroup(2,K);
SelGen:=[ ];

for z in SelGr do
SelGen:=Append(SelGen,Inverse(fs)(z));
end for;

SelOrbits:=[ ];

for i in [1..#SelGen] do
Aux:=[ ];
z1:=SelGen[i];
for k in [1..#Gal] do
g:=Gal[k];
for j in [1..#SelGen] do
z2:=SelGen[j];
if fs(g(z1)) eq fs(z2) then
Aux:=Append(Aux,j);
end if;
end for;
end for;
SelOrbits:=Append(SelOrbits,Aux);
end for;

SelOr:=[];
for i in [2..#SelOrbits] do
z:=SelOrbits[i,1];
Iso:=1;
for j in [1..#SelOr] do
for k in [1..3] do
if z eq SelOr[j,k] then
Iso:=0;
end if;
end for;
end for;
if Iso eq 1 then
SelOr:=Append(SelOr,SelOrbits[i]);
end if;
end for;

GalStable:=[];
GalStableElements:=[];
for i in [1..#SelOr] do
z1:=SelGen[SelOr[i,1]];
z2:=SelGen[SelOr[i,2]];
z3:=SelGen[SelOr[i,3]];
if fs(z1)*fs(z2) eq fs(z3) then
GalStable:=Append(GalStable,SelOr[i]);
GalStableElements:=Append(GalStableElements,[z1,z2,z3]);
end if;
end for;

SL2F3Ext:=[ ];
for j in [2..#GalStable] do
//for j in [2..2] do
R<x>:=PolynomialRing(K);
z1:=K!SelGen[GalStable[j,1]];
z2:=K!SelGen[GalStable[j,2]];
z3:=K!SelGen[GalStable[j,3]];
E1:=SplittingField(x^2-z1);
R<x>:=PolynomialRing(E1);
E:=SplittingField(x^2-z2);
R<x>:=PolynomialRing(E);



GalEF,m:=AutomorphismGroup(E,Q4);
GalGen:=[ ];
for i in [2..#Generators(GalEF)+1] do
GalGen:=Append(GalGen,m(GalEF.i));
end for;

ESel,fE:=pSelmerGroup(2,E);
ESelGen:=[ ];
for i in [1..#Generators(ESel)] do
ESelGen:=Append(ESelGen,Inverse(fE)(ESel.i));
end for;


M1:=[ ];
M2:=[ ];
M3:=[ ];
g1:=GalGen[1];
g2:=GalGen[2];
g3:=GalGen[3];

for z in ESelGen do
M1:=Append(M1,ElementToSequence(fE(g1(z))));
M2:=Append(M2,ElementToSequence(fE(g2(z))));
M3:=Append(M3,ElementToSequence(fE(g3(z))));
end for;

G1:=Matrix(GF(2),M1);
G2:=Matrix(GF(2),M2);
G3:=Matrix(GF(2),M3);

V1:=Eigenspace(G1,1);
V2:=Eigenspace(G2,1);
V3:=Eigenspace(G3,1);
V:=(V1 meet V2) meet V3;
ExtensionsAux:=[ ];
for v in V do
z:=Inverse(fE)(ESel!ElementToSequence(v));
L:=SplittingField(x^2-z);
Gcandidate:=AutomorphismGroup(L,Q4);
if IsIsomorphic(Gcandidate,SL(2,3)) then
ExtensionsAux:=Append(ExtensionsAux,L);
end if;
end for;
SL2F3Ext:=Append(SL2F3Ext,ExtensionsAux);
end for;

return <GalStableElements,SL2F3Ext>;
end function;

/*
//Example:
//We compute all inertia fields L corresponding to exceptional inertial types that become triply imprimitive over K_1 with the following command:
T:=Exceptionals(1);
//To handle better the output we split it.
GalStable:=T[1];
SL2F3:=T[2];
// Both GalStable and SL2F3 are lists of 5 elements corresponding to the 5 GalStable Orbits of K_1/(K_1)^2.
// The following comand shows representatives of the three elements in the first stable obrbit of K_1/(K_1)^2
GalStable[1];
// The square root of any of these representatives produces a quadratic extension M/K_1 from which the inertial type can be induced. All the possible inertia fields L that 
// come from types induced from M are store in 
SL2F3[1];

//Note for instance that SL2F3[4] and SL2F3[5] are empty since there are no exceptional types induced from the quadratic extensions generated by GalStable[4] or GalStable[5].
*/
